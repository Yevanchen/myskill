# Figma MCP API vs 直接导出 SVG 的差异

## 问题回顾

一开始效果不好的原因：**Figma API 返回的数据 ≠ 最终渲染的 SVG**

## 差异对比表

| 维度 | Figma API (MCP) | 直接导出 SVG |
|------|----------------|-------------|
| **文字** | 文本字符串 + 字体元数据 | 转换为 `<path>` 路径 |
| **Logo** | 组件实例引用 | 完整的 SVG 路径 |
| **坐标** | 可能是相对坐标 | 绝对坐标（画布） |
| **字体** | `{fontFamily: "Söhne", fontSize: 30.623}` | 已转换为路径形状 |
| **效果** | 元数据描述 | 实际的 SVG 滤镜代码 |
| **精确度** | 设计数据（逻辑层） | 渲染结果（视觉层） |

## 详细分析

### 1. 文字处理差异

#### Figma API 返回：
```json
{
  "type": "TEXT",
  "characters": "richard@dify.ai",
  "style": {
    "fontFamily": "Söhne",
    "fontSize": 30.623,
    "fontWeight": 300,
    "letterSpacing": -0.735
  },
  "absoluteBoundingBox": {
    "x": 86,
    "y": 340,
    "width": 200,
    "height": 35
  }
}
```

**问题**：
- ❌ 没有实际的字形路径
- ❌ 如果没有 Söhne 字体，无法准确渲染
- ❌ 字间距、行高的精确计算复杂
- ❌ 不同浏览器/系统渲染可能不同

#### 直接导出 SVG：
```xml
<!-- 文字已转换为路径（Outline text） -->
<path d="M83.6091 285.422V287.474C83.1497..." fill="#000"/>
<path d="M86.1601 282.207V279.481H88.5181..." fill="#000"/>
```

**优势**：
- ✅ 字形是精确的向量路径
- ✅ 不依赖字体文件
- ✅ 100% 视觉一致
- ✅ 跨平台完全相同

### 2. Dify Logo 差异

#### Figma API 返回：
```json
{
  "type": "INSTANCE",
  "componentId": "1:270",
  "name": "Dify Logo",
  "absoluteBoundingBox": {...}
}
```

**问题**：
- ❌ 只有组件引用，不是实际路径
- ❌ 需要额外 API 调用获取组件定义
- ❌ 需要解析组件内部的层级结构
- ❌ 可能有嵌套的组件和变体

#### 直接导出 SVG：
```xml
<!-- 完整的 4 个 Logo 路径，直接可用 -->
<path d="M850.58 66.9241C855.198..." fill="#0033FF"/>
<path d="M797.921 54.249H778.709..." fill="black"/>
<path d="M872.73 68.2884V72.3662..." fill="#0033FF"/>
<path d="M930.708 72.3584L921.669..." fill="black"/>
```

**优势**：
- ✅ Logo 已展平为路径
- ✅ 直接复制粘贴即可用
- ✅ 颜色、形状 100% 精确
- ✅ 无需解析组件树

### 3. 坐标系统差异

#### Figma API：
```json
{
  "absoluteBoundingBox": {
    "x": 86,
    "y": 340,
    "width": 200,
    "height": 35
  },
  "relativeTransform": [
    [1, 0, 86],
    [0, 1, 340]
  ]
}
```

**问题**：
- ❌ 可能需要计算父容器的 transform
- ❌ 多层嵌套时坐标计算复杂
- ❌ 旋转、缩放需要矩阵运算
- ❌ 可能有自动布局（Auto Layout）影响

#### 直接导出 SVG：
```xml
<text x="86" y="340">...</text>
```

**优势**：
- ✅ 已经是最终的绝对坐标
- ✅ 所有 transform 已应用
- ✅ 直接对应画布位置
- ✅ 不需要任何计算

### 4. 视觉效果差异

#### Figma API：
```json
{
  "effects": [
    {
      "type": "DROP_SHADOW",
      "color": {"r": 0, "g": 0, "b": 0, "a": 0.1},
      "offset": {"x": 0, "y": 19.14},
      "radius": 19.14,
      "spread": 0
    }
  ]
}
```

**问题**：
- ❌ 需要手动转换为 SVG filter
- ❌ 参数映射可能不精确
- ❌ 复杂效果（如叠加多个阴影）难处理
- ❌ 不同效果类型需要不同转换逻辑

#### 直接导出 SVG：
```xml
<filter id="filter0_d_1_488">
  <feOffset dy="19.1396"/>
  <feGaussianBlur stdDeviation="9.56981"/>
  <feComposite in2="hardAlpha" operator="out"/>
  <!-- 完整的滤镜定义，直接可用 -->
</filter>
```

**优势**：
- ✅ Figma 已转换为标准 SVG 语法
- ✅ 100% 还原设计效果
- ✅ 直接复制即可使用
- ✅ 支持所有 Figma 效果

## 为什么一开始效果不好

### 使用 Figma API 时的流程：

```
Figma 设计
    ↓
API 调用（获取节点数据）
    ↓
解析 JSON（提取属性）
    ↓
猜测和计算（文字位置、大小）
    ↓
生成 SVG（<text> 元素）
    ↓
❌ 结果：字体不对、位置偏移、效果缺失
```

**问题点**：
1. **字体回退**：Söhne → Inter → 系统字体，每一步都有偏差
2. **坐标猜测**：API 的 bounding box 不是文字基线位置
3. **效果近似**：阴影参数需要手动转换，可能不精确
4. **细节丢失**：字间距、行高的微调信息可能丢失

### 使用直接导出 SVG 的流程：

```
Figma 设计
    ↓
导出 SVG（File → Export）
    ↓
识别模板部分（背景、Logo、滤镜）
    ↓
替换内容部分（文字）
    ↓
✅ 结果：100% 像素级精确
```

**优势**：
1. **字形精确**：不依赖字体，路径就是答案
2. **坐标准确**：Figma 已完成所有计算
3. **效果完整**：所有滤镜、效果已转换
4. **所见即所得**：导出的就是设计的

## 实际案例对比

### 场景：显示 "Richard Yan"

#### 方式 A：Figma API
```python
# 从 API 获取
name_data = {
    'characters': 'Richard Yan',
    'fontFamily': 'Söhne',
    'fontSize': 202,
    'fontWeight': 700,
    'x': 84,
    'y': 260  # 这是 bounding box 的 y！
}

# 生成 SVG
svg = f'<text x="84" y="260" font-family="Söhne">Richard Yan</text>'

# 问题：
# - 如果没有 Söhne 字体，浏览器用备用字体
# - y="260" 是 box 顶部，不是基线，文字会偏上
# - 字间距、字重可能渲染不同
```

#### 方式 B：直接导出 SVG
```xml
<!-- Figma 已将文字转为路径 -->
<path d="M84 260.5 L88.2 260.5 C89.1 260.5..." fill="#000"/>
<path d="M95.3 260.5 L99.8 260.5 C..." fill="#000"/>
<!-- 每个字母都是精确的路径 -->

<!-- 或保留为 text 元素，但坐标已调整为正确的基线位置 -->
<text x="84" y="245" font-family="Söhne">Richard Yan</text>
<!-- y 坐标已经是正确的！-->
```

## 总结

| | Figma API | 导出 SVG |
|---|----------|----------|
| **信息层级** | 设计数据（逻辑） | 渲染结果（视觉） |
| **准确度** | 需要转换和猜测 | 100% 精确 |
| **依赖** | 字体文件、计算逻辑 | 无依赖 |
| **复杂度** | 高（需要解析、计算） | 低（复制粘贴） |
| **适用场景** | 动态生成、编程控制 | 模板复用、视觉精确 |

## 最佳实践

### 什么时候用 Figma API (MCP)？
- ✅ 需要**动态**生成内容（如批量生成名片）
- ✅ 需要访问设计的**结构**（组件、变体、样式）
- ✅ 需要**编程控制**设计（自动化设计工具）
- ✅ 需要提取设计**tokens**（颜色、字体、间距）

### 什么时候直接导出 SVG？
- ✅ 需要**像素级精确**的视觉还原（名片、Logo）
- ✅ 设计已**最终定稿**，不需要频繁修改
- ✅ 需要**快速**实现，不想处理字体、坐标等细节
- ✅ 需要**跨平台一致性**，不依赖字体文件

### 混合方案（我们使用的）：
1. **导出 SVG** 作为模板（保留 Logo、背景、效果）
2. **识别可变部分**（文字内容）
3. **用脚本替换**（保持模板结构，替换内容）
4. **结果**：既有精确性，又有灵活性

## 结论

这就是为什么我们的工作流程是：

```
Figma 导出 SVG → 识别模板部分 → Python 脚本替换内容
```

而不是：

```
Figma API → 解析数据 → 重新生成 SVG
```

前者是"套模板"（简单、精确），后者是"重建设计"（复杂、近似）。

**像人类设计师一样思考：拿到模板，修改内容，完成！** 🎯
